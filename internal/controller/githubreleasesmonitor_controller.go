/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"fmt"
	"time"

	"github.com/go-logr/logr" // Add this line to import the missing package
	// Add this line to import the package that contains the 'contains' function
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	webappv1 "csye7125-su24-team14/cve-operator/api/v1"
)

const (
	resourceName      = "example-resource"
	resourceNamespace = "default"
)

// GitHubReleasesMonitorReconciler reconciles a GitHubReleasesMonitor object
type GitHubReleasesMonitorReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=webapp.csye7125-su24-team14,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=webapp.csye7125-su24-team14,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=webapp.csye7125-su24-team14,resources=githubreleasesmonitors/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the GitHubReleasesMonitor object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.18.4/pkg/reconcile
func (r *GitHubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	l := log.FromContext(ctx)
	l.Info("Enter GitHubReleasesMonitorReconciler", "req", req)
	// TODO(user): your logic here
	instance := &webappv1.GitHubReleasesMonitor{}
	err := r.Get(ctx, types.NamespacedName{Name: req.Name, Namespace: req.Namespace}, instance)
	if err != nil {
		// return client.IgnoreNotFound(err)
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}
	l.Info("Enter Reconcile", "instance", instance)
	l.Info("Instance", "instance.Spec.MonitorFrom", instance.Spec.MonitorFrom)
	l.Info("Instance", "instance.Spec.Url", instance.Spec.Url)
	l.Info("Instance", "instance.Status", instance.Status)
	if instance.Status.Releases == nil {
		instance.Status.Releases = []string{}
	}
	if instance.Status.MonitorFrom == "" {
		instance.Status.MonitorFrom = instance.Spec.MonitorFrom
	}
	l.Info("Found Monitor Instance", "instance", instance)
	if err := r.reconcileGitHubRelease(ctx, req, instance, l); err != nil {
		return ctrl.Result{}, err
	}
	return ctrl.Result{}, nil
}
func (r *GitHubReleasesMonitorReconciler) reconcileGitHubRelease(ctx context.Context, req ctrl.Request, instance *webappv1.GitHubReleasesMonitor, l logr.Logger) error {

	monitorFrom := instance.Spec.MonitorFrom

	if monitorFrom != "now" {
		startDate, err := time.Parse("2006-01-02", monitorFrom)
		if err != nil {
			return fmt.Errorf("invalid date format: %v", err)
		}
		now := time.Now().UTC()
		// Check API for every date from startDate to now
		for date := startDate; date.Before(now); date = date.AddDate(0, 0, 1) {
			dateStr := date.Format("2006-01-02")
			fmt.Println("Checking API for date:", dateStr)
			// url := instance.Spec.Url
			// "https://github.com/CVEProject/cvelistV5/releases/download/cve_2024-07-20_2300Z/2024-07-20_delta_CVEs_at_2300Z.zip"
			// https: //github.com/CVEProject/cvelistV5/releases/download/cve_2024-07-21_0000Z/2024-07-21_all_CVEs_at_midnight.zip.zip
			// url := "https://github.com/CVEProject/cvelistV5/releases" + "/download/cve_" + dateStr + "_0000Z/" + dateStr + "_all_CVEs_at_midnight.zip.zip"
			url := "https://github.com/CVEProject/cvelistV5/releases" + "/download/cve_" + dateStr + "_2100Z/" + dateStr + "_delta_CVEs_at_2100Z.zip"
			fmt.Println(url)
			//"https://github.com/CVEProject/cvelistV5/releases/download/cve_2024-07-20_0000Z/2024-07-20_all_CVEs_at_midnight.zip.zip"
			// url := fmt.Sprintf("https://api.example.com/status?date=%s", dateStr)
			releaseName := "githubrelease-" + dateStr + "-0000z"
			if instance.Status.Releases != nil {
				if contains(instance.Status.Releases, releaseName) {
					continue
				} else {
					if err := checkAndCreateGithubRelease(ctx, r.Client, url, releaseName); err != nil {
						fmt.Println(err)
					} else {
						instance.Status.Releases = append(instance.Status.Releases, releaseName)
						instance.Status.LastRetrievedTime = metav1.Now()
					}
				}

			}

		}
	}

	// resp, err := http.Get(instance.Spec.Url + "/latest")
	// if err != nil {
	// 	return fmt.Errorf("failed to get API status: %w", err)
	// }
	// defer resp.Body.Close()

	// ticker := time.NewTicker(instance.Spec.Schedule)
	// defer ticker.Stop()

	// go func() {
	// 	for range ticker.C {
	// 		if err := checkAndCreateGithubRelease(ctx, r.Client, "https://api.example.com/status"); err != nil {
	// 			// Handle error
	// 		}
	// 	}
	// }()
	// Define the resource to be created
	// newResource := &webappv1.GitHubReleasesMonitor{
	// 	ObjectMeta: metav1.ObjectMeta{
	// 		Name:      resourceName,
	// 		Namespace: resourceNamespace,
	// 	},
	// 	Spec: webappv1.GitHubReleasesMonitorSpec{
	// 		Url:         "https://github.com/CVEProject/cvelistV5/releases/download",
	// 		MonitorFrom: "2024-01-01T00:00:00Z",
	// 	},
	// }

	// // Check if the resource already exists
	// existingResource := &examplev1.SomeResource{}
	// err = r.Get(ctx, client.ObjectKey{Namespace: resourceNamespace, Name: resourceName}, existingResource)
	// if err != nil && client.IgnoreNotFound(err) != nil {
	// 	// Error occurred while fetching the resource
	// 	return reconcile.Result{}, err
	// }

	// if err == nil {
	// 	// Resource already exists, no need to create it
	// 	return reconcile.Result{}, nil
	// }

	// // Resource does not exist, create it
	// err = r.Create(ctx, newResource)
	// if err != nil {
	// 	return reconcile.Result{}, fmt.Errorf("failed to create resource: %w", err)
	// }
	return nil
}

func contains(slice []string, item string) bool {
	for _, v := range slice {
		if v == item {
			return true
		}
	}
	return false
}

func checkAndCreateGithubRelease(ctx context.Context, kubeClient client.Client, url string, releaseName string) error {
	// https://github.com/CVEProject/cvelistV5/releases/download/cve_2024-07-20_0000Z/2024-07-20_delta_CVEs_at_0000Z.zip"
	// now := time.Now().UTC()
	// flooredTime := time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), 0, 0, 0, time.UTC)
	// // Format the time as "YYYY-MM-DD_HHmmZ"
	// formattedTime := flooredTime.Format("2006-01-02_1500Z")

	// fmt.Println(formattedTime) //2024-07-21_2300Z
	// lastFiveDigits := formattedTime[len(formattedTime)-5:]
	// url = url + "/cve_" + formattedTime + "/" + formattedTime + "_delta_CVEs_at_" + lastFiveDigits + ".zip"
	// Perform GET request to the API
	// resp, err := http.Get(url)
	// if err != nil {
	// 	return fmt.Errorf("failed to get API status: %w", err)
	// }
	// defer resp.Body.Close()

	// // Check if status code is 200
	// if resp.StatusCode == http.StatusOK {
	// Create Kubernetes Job
	githubRelease := &webappv1.GitHubReleases{
		ObjectMeta: metav1.ObjectMeta{
			Name:      releaseName,
			Namespace: "webapp-producer",
		},
		Spec: webappv1.GitHubReleasesSpec{
			Url: url,
		},
	}
	if err := kubeClient.Create(ctx, githubRelease); err != nil {
		return fmt.Errorf("failed to create GitHubRelease: %w", err)
	}
	// job := &batchv1.Job{
	// 	ObjectMeta: metav1.ObjectMeta{
	// 		Name:      "GitHubRelease_" + formattedTime,
	// 		Namespace: "default",
	// 	},
	// 	Spec: batchv1.JobSpec{
	// 		Template: corev1.PodTemplateSpec{
	// 			Spec: corev1.PodSpec{
	// 				Containers: []corev1.Container{
	// 					{
	// 						Name:  "example-container",
	// 						Image: "example-image",
	// 					},
	// 				},
	// 				RestartPolicy: corev1.RestartPolicyOnFailure,
	// 			},
	// 		},
	// 	},
	// }

	// if err := kubeClient.Create(ctx, job); err != nil {
	// 	return fmt.Errorf("failed to create Kubernetes job: %w", err)
	// }
	// }

	return nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *GitHubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&webappv1.GitHubReleasesMonitor{}).
		Complete(r)
}
