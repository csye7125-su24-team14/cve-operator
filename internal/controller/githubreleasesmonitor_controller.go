/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/go-logr/logr" // Add this line to import the missing package
	// Add this line to import the package that contains the 'contains' function
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/wait"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	webappv1 "csye7125-su24-team14/cve-operator/api/v1"
)

const (
	resourceName                  = "example-resource"
	resourceNamespace             = "default"
	gitHubReleaseMonitorFinalizer = "finalizer.githubreleasemonitor.webapp.com"
	requestTimeout                = time.Minute * 5
)

// GitHubReleasesMonitorReconciler reconciles a GitHubReleasesMonitor object
type GitHubReleasesMonitorReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=webapp.csye7125-su24-team14,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=webapp.csye7125-su24-team14,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=webapp.csye7125-su24-team14,resources=githubreleasesmonitors/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the GitHubReleasesMonitor object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.18.4/pkg/reconcile
func (r *GitHubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	l := log.FromContext(ctx)
	l.Info("Enter GitHubReleasesMonitorReconciler ", "req", req)
	instance := &webappv1.GitHubReleasesMonitor{}
	err := r.Get(ctx, types.NamespacedName{Name: req.Name, Namespace: req.Namespace}, instance)
	if err != nil {
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}
	l.Info("Enter GitHubReleasesMonitorReconciler", "instance", instance)
	if instance.Status.Releases == nil {
		l.Info("Found Status Releases as nil", "Release", instance.Status.Releases)
		instance.Status.Releases = []webappv1.GitHubReleases{}
	}
	if instance.Status.MonitorFrom == "" {
		l.Info("Found Status MonitorFrom as nil", "MonitorFrom", instance.Status.MonitorFrom)
		instance.Status.MonitorFrom = instance.Spec.MonitorFrom
	}
	l.Info("Found Monitor Instance", "instance", instance)

	if instance.ObjectMeta.DeletionTimestamp.IsZero() {
		// Resource is not being deleted; handle normal processing
		if err := r.addFinalizer(instance); err != nil {
			return ctrl.Result{}, err
		}
	} else {
		// Resource is being deleted; handle finalization
		if contains(instance.GetFinalizers(), gitHubReleaseMonitorFinalizer) {
			// Delete the all github releases
			fmt.Println("Deleting all GitHub Releases")
			ghReleases, err := r.getActiveGithubRelease(ctx, l)
			if err != nil {
				return ctrl.Result{}, err
			}
			for _, release := range ghReleases.Items {
				fmt.Println("Deleting GitHub Release: ", release.Name)
				err := r.deleteGitHubRelease(ctx, release.Name, instance.Namespace)
				if err != nil {
					fmt.Println("Failed to delete GitHub Release: ", release.Name)
					fmt.Println("Error to delete GitHub Release: ", err)
					return ctrl.Result{}, err
				}
			}

			// Remove the finalizer to complete the deletion process
			instance.SetFinalizers(remove(instance.GetFinalizers(), gitHubReleaseMonitorFinalizer))
			if err := r.Update(ctx, instance); err != nil {
				return ctrl.Result{}, err
			}
		}
		return ctrl.Result{RequeueAfter: requestTimeout}, nil
	}

	githubReleaseList := &webappv1.GitHubReleasesList{}
	if _, err := r.getActiveGithubRelease(ctx, l); err != nil {
		return ctrl.Result{}, err
	}
	if err := r.checkDifference(githubReleaseList, instance, l); err != nil {
		fmt.Println("Error in checking difference: ", err)
	}
	if len(instance.Status.Releases) != len(githubReleaseList.Items) {
		instance.Status.Releases = githubReleaseList.Items
	}
	if err := r.reconcileGitHubRelease(ctx, instance, l); err != nil {
		return ctrl.Result{}, err
	}
	err = r.Status().Update(ctx, instance)
	if err != nil {
		return ctrl.Result{}, err
	}
	return ctrl.Result{RequeueAfter: requestTimeout}, nil
}

func (r *GitHubReleasesMonitorReconciler) checkDifference(githubReleaseList *webappv1.GitHubReleasesList, instance *webappv1.GitHubReleasesMonitor, l logr.Logger) error {
	activeMap := make(map[string]bool)
	// activeReleaseList:= []webappv1.GitHubReleases{}
	for _, item := range githubReleaseList.Items {
		activeMap[item.Name] = true
	}
	for _, item := range instance.Status.Releases {
		if !activeMap[item.Name] {
			fmt.Printf("Release not found: %s\n", item.Name)
		}
	}
	return nil

}

func (r *GitHubReleasesMonitorReconciler) getActiveGithubRelease(ctx context.Context, l logr.Logger) (*webappv1.GitHubReleasesList, error) {
	var githubReleaseList webappv1.GitHubReleasesList
	if err := r.List(ctx, &githubReleaseList); err != nil {
		return &githubReleaseList, fmt.Errorf("failed to list pods: %v", err)
	}

	// Print the list of Pods
	for _, pod := range githubReleaseList.Items {
		fmt.Printf("Found Pod: %s/%s\n", pod.Namespace, pod.Name)
	}
	return &githubReleaseList, nil
}
func (r *GitHubReleasesMonitorReconciler) reconcileGitHubRelease(ctx context.Context, instance *webappv1.GitHubReleasesMonitor, l logr.Logger) error {

	monitorFrom := instance.Spec.MonitorFrom

	if monitorFrom != "now" {
		startDate, err := time.Parse("2006-01-02", monitorFrom)
		if err != nil {
			return fmt.Errorf("invalid date format: %v", err)
		}

		now := time.Now().UTC().AddDate(0, 0, -1)
		// Check API for every date from startDate to now
		for date := startDate; date.Before(now); date = date.AddDate(0, 0, 1) {
			dateStr := date.Format("2006-01-02")
			fmt.Println("Checking API for date:", dateStr)
			url := instance.Spec.Url + "/download/cve_" + dateStr + "_at_end_of_day/" + dateStr + "_delta_CVEs_at_end_of_day.zip"
			fmt.Println("Checking API for URL: ", url)
			releaseName := "githubrelease-" + dateStr + "-at-end-of-day"
			if checkURLExists(url) {
				if instance.Status.Releases != nil {
					if containsObject(instance.Status.Releases, releaseName) {
						continue
					} else {
						newRelease, err := checkAndCreateGithubRelease(ctx, r.Client, url, releaseName)
						if err != nil {
							l.Error(err, "Failed to check and create GitHub release")
						} else {
							instance.Status.Releases = append(instance.Status.Releases, *newRelease)
							instance.Status.LastRetrievedTime = metav1.Now()
						}
					}

				}
			} else {
				fmt.Println("URL does not exist")
			}

		}

	}
	nearestHour := time.Now().UTC().Truncate(time.Hour)
	dateStr := nearestHour.Format("2006-01-02_1500Z")
	url := fmt.Sprintf(instance.Spec.Url+"/download/cve_%s/%s_delta_CVEs_at_%s.zip",
		dateStr, dateStr[:10], dateStr[11:16])
	fmt.Println("Checking API Now for URL: ", url)

	// Check if the URL exists
	if checkURLExists(url) {
		releaseName := "githubrelease-delta-" + dateStr[:10] + "-" + dateStr[11:15]
		fmt.Println("Checking delta release: ", releaseName)
		if instance.Status.Releases == nil || !containsObject(instance.Status.Releases, releaseName) {
			if newRelease, err := checkAndCreateGithubRelease(ctx, r.Client, url, releaseName); err != nil {
				l.Error(err, "Failed to check and create GitHub release")
			} else {
				instance.Status.Releases = append(instance.Status.Releases, *newRelease)
				instance.Status.LastRetrievedTime = metav1.Now()
			}
		}
	} else {
		fmt.Println("URL does not exist")
	}

	return nil
}

func checkURLExists(url string) bool {
	resp, err := http.Head(url)
	if err != nil {
		return false
	}
	return resp.StatusCode == http.StatusOK
}

func contains(slice []string, item string) bool {
	for _, v := range slice {
		if v == item {
			return true
		}
	}
	return false
}
func containsObject(slice []webappv1.GitHubReleases, name string) bool {
	for _, v := range slice {
		if v.Name == name {
			return true
		}
	}
	return false
}

func checkAndCreateGithubRelease(ctx context.Context, kubeClient client.Client, url string, releaseName string) (*webappv1.GitHubReleases, error) {
	githubRelease := &webappv1.GitHubReleases{
		ObjectMeta: metav1.ObjectMeta{
			Name:      releaseName,
			Namespace: "webapp-producer",
		},
		Spec: webappv1.GitHubReleasesSpec{
			Url: url,
		},
	}
	if err := kubeClient.Create(ctx, githubRelease); err != nil {
		return nil, fmt.Errorf("failed to create GitHubRelease: %w", err)
	}

	return githubRelease, nil
}

func (r *GitHubReleasesMonitorReconciler) addFinalizer(instance *webappv1.GitHubReleasesMonitor) error {
	// Check if the finalizer is already present
	if !contains(instance.GetFinalizers(), gitHubReleaseMonitorFinalizer) {
		// Add the finalizer to the list
		instance.SetFinalizers(append(instance.GetFinalizers(), gitHubReleaseMonitorFinalizer))
		// Update the resource to reflect the new finalizer
		err := r.Update(context.Background(), instance)
		if err != nil {
			return err
		}
	}
	return nil
}

func (r *GitHubReleasesMonitorReconciler) deleteGitHubRelease(ctx context.Context, releaseName string, namespace string) error {
	release := &webappv1.GitHubReleases{}
	err := r.Get(ctx, types.NamespacedName{Name: releaseName, Namespace: namespace}, release)
	if err != nil {
		if client.IgnoreNotFound(err) != nil {
			return fmt.Errorf("failed to get GitHubRelease: %w", err)
		}
	}

	// Add propagation policy for cascading deletion
	deletePolicy := metav1.DeletePropagationForeground
	deleteOptions := client.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	}

	if err := r.Delete(ctx, release, &deleteOptions); err != nil {
		return fmt.Errorf("failed to delete GitHubRelease: %w", err)
	}

	// Wait for the job to be deleted
	err = wait.PollImmediate(time.Second, time.Minute, func() (bool, error) {
		if err := r.Get(ctx, types.NamespacedName{Name: releaseName, Namespace: namespace}, &webappv1.GitHubReleases{}); err != nil {
			if errors.IsNotFound(err) {
				return true, nil
			}
			return false, err
		}
		return false, nil
	})

	if err != nil {
		return fmt.Errorf("failed to wait for github release deletion: %w", err)
	}

	return nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *GitHubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&webappv1.GitHubReleasesMonitor{}).
		Complete(r)
}
